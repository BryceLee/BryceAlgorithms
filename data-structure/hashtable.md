Hashtable是基于数组的扩展，利用数组可以通过下标直接获取对应的值的特性。
通过Hash函数把key映射程下标，然后把value存在数组对应下标里。

散列函数设计
- key对应hash值是非负整数
- key值相同，hash值相同
- key值不相同，hash不相同

但是第三点无法保证，会产生了冲突；
从设计角度而言，散列函数的value要尽可能随机，均匀分布，这样才能最小化散列冲突
- 开发寻址法
    - Linear Probing 线性探测，从冲突位置一直返回找，直到找到位置；或者为空值就停止
        - Java中的LinkedHashMap就采用了链表法解决散列冲突
    - 二次探测
    - 双重散列
- 链表法
    - 插入 ： 理想情况下O（1），如果出现扩容,重新申请内容空间，重新计算哈希位置，并且搬移数据，时间复杂度O(n)
    - 查找和删除，需要通过散列函数计算出数组下标，然后遍历链表查找或删除，时间复杂度和链表长度成成比，O（l）,l是链表长度
        - 查询效率和负载椅子，散列函数，散列冲突都有关
        - 可能收到Donial-of-Service Attack(Dos Attack)
    - Java中的ThreadLocalMap开发寻址发来解决散列冲突
    - 当单个节点的数据流远大于指针的内存占用，比较适合用链表法来规避散列冲突
    - 优化策略：红黑树代替链表
- 更高效的扩容：
    - 扩张不搬移数据
    - 插入一个数据，搬移一个旧数据

